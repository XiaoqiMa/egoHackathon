[
["index.html", "e.GO Digital Hackathon Section 1 Task", " e.GO Digital Hackathon Team: Hugs for bugs 2019-05-24 Section 1 Task The e.GO life is generating, collecting and processing serveral data per second. Those data could be very valuable for us. Especially when you think of developing new innovative business models. Your task is to develop value-adding services for the e.GO Life and its user considering the provided data. "],
["value-adding-services.html", "Section 2 Value-adding services", " Section 2 Value-adding services Our services should support at least the following functions: Intelligently choose the parking lot location convenient cheap price support egoPay Shortly reservation for the parking lot estimating the arrival time automatically reserve the parking space in advance message notification Immediately payment – egoPay no worry about parking time automatic charging fees while leaving Ego drive-thru food reservation from supermarket food pick up from parking lot food payment by egoPay "],
["dataset-overview.html", "Section 3 Dataset Overview 3.1 We prepare a dataset, as shown below 3.2 Get current location, update location", " Section 3 Dataset Overview 3.1 We prepare a dataset, as shown below import pandas as pd df = pd.read_csv(&#39;location.csv&#39;, sep=&#39;\\t&#39;, index_col=0) df ## location_name latitude longitude price/hour is_outdoor ego_pay ## 0 e.Go 50.781624 6.046581 2 1 1 ## 1 Super C 50.778430 6.078702 3 1 0 ## 2 Bushof 50.777557 6.090270 4 1 0 ## 3 Hauptbahnhof 50.767911 6.091582 4 0 1 ## 4 Euregiozoo 50.763672 6.115565 3 1 1 location_name: the parking plot location latitude: latitude of the parking plot longtitude: longtitude of the parking plot price/hour: price to be charged per hour is_outdoor: is the parking plot outdoor or inside ego_pay: does the parking plot support “EgoPay” 3.2 Get current location, update location import requests class EgoCar: def __init__(self, api_url): self.api_url = api_url self.api_key = &#39;7443363c-4304-4c56-9df0-6af4af40c613&#39; self.header = {&#39;Content-type&#39;: &#39;application/json&#39;, &#39;X-Api-Key&#39;: self.api_key} def get_location(self): res = requests.get(self.api_url, headers=self.header) location = res.json()[&#39;location&#39;] return location def update_location(self, new_location): x, y = new_location.split(&#39;,&#39;) x, y = float(x), float(y) if x &gt;= -90 and x &lt;= 90 and y &gt;= -90 and y &lt;= 90: data = {&#39;location&#39;: new_location} requests.patch(self.api_url, json=data, headers=self.header) print(&#39;new location: &#39;, new_location) else: print(&#39;[Error] Latitude value must be between -90 and 90&#39;) get current location api_url = &#39;https://ego-vehicle-api.azurewebsites.net/api/v1/vehicle/signals&#39; ego_car = EgoCar(api_url) print(&#39;current location: &#39;, ego_car.get_location()) ## current location: 50.00, 6.00 update location ego_car.update_location(&#39;50.00, 6.00&#39;) ## new location: 50.00, 6.00 "],
["intelligent-choose-parking-lot.html", "Section 4 Intelligent choose parking lot", " Section 4 Intelligent choose parking lot Intelligent, we mean that we should use smart algorithms to choose the most appropriate parking lot, considering the distance, price and etc. Calculate Geographical distance from geopy.distance import geodesic from geopy.geocoders import Nominatim class GeoDistance: def __init__(self): self.geolocator = Nominatim(user_agent=&quot;demo&quot;) def get_geo_position(self, location): addr = self.geolocator.geocode(location) return (addr.latitude, addr.longitude) def get_location(self, geo_position): location = self.geolocator.reverse(geo_position) try: addr = location.raw[&#39;address&#39;] return &#39;{road}, {city_district}, {city}, {postcode}&#39;.format(**addr) except: return location.address def calc_geo_distance(self, origin, destination): distance = geodesic(origin, destination).km return distance First get the current location api_url = &#39;https://ego-vehicle-api.azurewebsites.net/api/v1/vehicle/signals&#39; ego_car = EgoCar(api_url) curr_loc = ego_car.get_location() print(&#39;current location: &#39;, curr_loc) ## current location: 50.00, 6.00 geo_dis = GeoDistance() addr = geo_dis.get_location(curr_loc) print(&#39;current address: &#39;, addr) ## current address: Kiischpelt, Canton Wiltz, 9776, Lëtzebuerg Calculate distance to parking lot pd.options.mode.chained_assignment = None df_dis = df[[&#39;location_name&#39;, &#39;latitude&#39;, &#39;longitude&#39;]] origin = ego_car.get_location() destination = zip(df_dis[&#39;latitude&#39;].values, df_dis[&#39;longitude&#39;].values) df_dis[&#39;distance/km&#39;] = [geo_dis.calc_geo_distance(origin, des) for des in destination] df_dis.sort_values(&#39;distance/km&#39;, ascending=True) ## location_name latitude longitude distance/km ## 4 Euregiozoo 50.763672 6.115565 85.344859 ## 3 Hauptbahnhof 50.767911 6.091582 85.667684 ## 2 Bushof 50.777557 6.090270 86.730648 ## 1 Super C 50.778430 6.078702 86.770605 ## 0 e.Go 50.781624 6.046581 87.008247 Smart choice (toy example, with different weight on attributes) distance: 0.5 price: 0.2 is_outdoor: 0.1 egoPay: 0.2 from sklearn.preprocessing import MinMaxScaler scaler = MinMaxScaler() df_new = df[[&#39;price/hour&#39;, &#39;is_outdoor&#39;, &#39;ego_pay&#39;]] df_new[&#39;is_outdoor&#39;] = df_new[&#39;is_outdoor&#39;].apply(lambda x : x ^ 1) df_new[&#39;ego_pay&#39;] = df_new[&#39;ego_pay&#39;].apply(lambda x : x ^ 1) df_weight = df_new.join(df_dis[&#39;distance/km&#39;], how=&#39;inner&#39;) # max-min scaler norm_values = scaler.fit_transform(df_weight.values) norm_values ## array([[0. , 0. , 0. , 1. ], ## [0.5 , 0. , 1. , 0.85713399], ## [1. , 0. , 1. , 0.83311221], ## [1. , 1. , 0. , 0.19407646], ## [0.5 , 0. , 0. , 0. ]]) the smaller value, the better choice import numpy as np cost = np.sum(norm_values * [0.2, 0.1, 0.2, 0.5], axis=1) df_weight[&#39;cost&#39;] = cost.T df_weight.sort_values(&#39;cost&#39;, ascending=True) ## price/hour is_outdoor ego_pay distance/km cost ## 4 3 0 0 85.344859 0.100000 ## 3 4 1 0 85.667684 0.397038 ## 0 2 0 0 87.008247 0.500000 ## 1 3 0 1 86.770605 0.728567 ## 2 4 0 1 86.730648 0.816556 It seems the best choice is Euregiozoo "],
["google-map-visulization.html", "Section 5 Google Map Visulization", " Section 5 Google Map Visulization Code to add marker and direction class GeoMaps: def __init__(self, curr_location): self.key = &#39;AIzaSyAT-8WclaMhy1oSPq9m5TxN9p7FJHZcdcw&#39; gmaps.configure(api_key=self.key) self.curr_location = curr_location self.fig = gmaps.figure(center=self.curr_location, zoom_level=12) def add_marker(self, marker_pos): markers = gmaps.marker_layer(marker_pos) self.fig.add_layer(markers) return self.fig def add_direction(self, origin, destination): to_destination = gmaps.directions_layer(origin, destination) self.fig.add_layer(to_destination) return self.fig def get_curr_location(self): return self.curr_location def update_location(self, new_location): self.curr_location = new_location Mark current location knitr::include_graphics(&quot;img/google_marker.png&quot;) Figure 5.1: google map with marker Draw car driving direction knitr::include_graphics(&quot;img/car_direction.png&quot;) Figure 5.2: google map with car driving direction "]
]
