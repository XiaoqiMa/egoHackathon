[
["e-gp-park.html", "Section 4 e.GP Park", " Section 4 e.GP Park Intelligent, we mean that we should use smart algorithms to choose the most appropriate parking lot, considering the distance, price and etc. Calculate Geographical distance from geopy.distance import geodesic from geopy.geocoders import Nominatim class GeoDistance: def __init__(self): self.geolocator = Nominatim(user_agent=&quot;demo&quot;) def get_geo_position(self, location): addr = self.geolocator.geocode(location) return (addr.latitude, addr.longitude) def get_location(self, geo_position): location = self.geolocator.reverse(geo_position) try: addr = location.raw[&#39;address&#39;] return &#39;{road}, {city_district}, {city}, {postcode}&#39;.format(**addr) except: return location.address def calc_geo_distance(self, origin, destination): distance = geodesic(origin, destination).km return distance First get the current location api_url = &#39;https://ego-vehicle-api.azurewebsites.net/api/v1/vehicle/signals&#39; ego_car = EgoCar(api_url) curr_loc = ego_car.get_location() print(&#39;current location: &#39;, curr_loc) ## current location: 51.00, 6.00 geo_dis = GeoDistance() addr = geo_dis.get_location(curr_loc) print(&#39;current address: &#39;, addr) ## current address: Lindenhof, Hohenbusch, Gangelt, Kreis Heinsberg, Regierungsbezirk KÃ¶ln, Nordrhein-Westfalen, 52538, Deutschland Calculate distance to parking lot pd.options.mode.chained_assignment = None df_dis = df[[&#39;location_name&#39;, &#39;latitude&#39;, &#39;longitude&#39;]] origin = ego_car.get_location() destination = zip(df_dis[&#39;latitude&#39;].values, df_dis[&#39;longitude&#39;].values) df_dis[&#39;distance/km&#39;] = [geo_dis.calc_geo_distance(origin, des) for des in destination] df_dis.sort_values(&#39;distance/km&#39;, ascending=True) ## location_name latitude longitude distance/km ## 0 e.Go 50.781624 6.046581 24.513606 ## 1 Super C 50.778430 6.078702 25.263182 ## 2 Bushof 50.777557 6.090270 25.548138 ## 3 Hauptbahnhof 50.767911 6.091582 26.611184 ## 4 Euregiozoo 50.763672 6.115565 27.519752 Smart choice (toy example, with different weight on attributes) distance: 0.5 price: 0.2 is_outdoor: 0.1 egoPay: 0.2 from sklearn.preprocessing import MinMaxScaler scaler = MinMaxScaler() df_new = df[[&#39;price/hour&#39;, &#39;is_outdoor&#39;, &#39;ego_pay&#39;]] df_new[&#39;is_outdoor&#39;] = df_new[&#39;is_outdoor&#39;].apply(lambda x : x ^ 1) df_new[&#39;ego_pay&#39;] = df_new[&#39;ego_pay&#39;].apply(lambda x : x ^ 1) df_weight = df_new.join(df_dis[&#39;distance/km&#39;], how=&#39;inner&#39;) # max-min scaler norm_values = scaler.fit_transform(df_weight.values) norm_values ## array([[0. , 0. , 0. , 0. ], ## [0.5 , 0. , 1. , 0.24934802], ## [1. , 0. , 1. , 0.34413907], ## [1. , 1. , 0. , 0.69776329], ## [0.5 , 0. , 0. , 1. ]]) the smaller value, the better choice import numpy as np cost = np.sum(norm_values * [0.2, 0.1, 0.2, 0.5], axis=1) df_weight[&#39;cost&#39;] = cost.T df_weight.sort_values(&#39;cost&#39;, ascending=True) ## price/hour is_outdoor ego_pay distance/km cost ## 0 2 0 0 24.513606 0.000000 ## 1 3 0 1 25.263182 0.424674 ## 2 4 0 1 25.548138 0.572070 ## 4 3 0 0 27.519752 0.600000 ## 3 4 1 0 26.611184 0.648882 It seems the best choice is Euregiozoo video demo for parking library(vembedr) embed_url(&quot;https://www.youtube.com/watch?v=lPfmxcEOriQ&amp;feature=youtu.be&quot;) "]
]
